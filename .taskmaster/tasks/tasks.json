{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository and Development Environment",
        "description": "Create a monorepo structure with Docker configuration for both frontend and backend development",
        "details": "Initialize a Git repository with a monorepo structure containing frontend/ and backend/ directories. Create Docker and Docker Compose configurations to ensure consistent development environments. Set up .gitignore files, README.md with setup instructions, and a versions.md file to pin dependency versions (Node 18.19.0, Python 3.12.0, etc.). Configure Docker Compose to run both services together with appropriate networking.",
        "testStrategy": "Verify Docker containers build and run successfully on different platforms (Linux, macOS, Windows). Ensure hot-reloading works in development mode. Test that frontend can reach backend API endpoints through Docker networking.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Monorepo Structure with Git",
            "description": "Create the initial Git repository with the correct monorepo structure including frontend and backend directories, along with other required top-level directories and files.",
            "dependencies": [],
            "details": "Create a new Git repository. Set up the directory structure with frontend/ and backend/ as the main directories. Add additional directories like docs/ and .github/ if needed. Create initial README.md with project overview and setup instructions. Create versions.md file to document and pin dependency versions (Node 18.19.0, Python 3.12.0). Set up appropriate .gitignore files at the root and in subdirectories to exclude node_modules, __pycache__, and other build artifacts.",
            "status": "done",
            "testStrategy": "Verify the repository structure matches the required layout. Confirm all required directories and files exist. Validate .gitignore files contain appropriate entries."
          },
          {
            "id": 2,
            "title": "Create Docker Configuration for Frontend and Backend",
            "description": "Develop Dockerfiles for both frontend and backend services with proper multi-stage builds, non-root user configuration, and correct build contexts.",
            "dependencies": [],
            "details": "Create a Dockerfile for the frontend service using Node 18.19.0 as the base image. Implement multi-stage build to optimize the production image size. Create a Dockerfile for the backend service using Python 3.12.0. Configure both Dockerfiles to run as non-root users for security. Set up proper COPY and RUN commands to install dependencies and build the applications. Configure appropriate EXPOSE ports and entry commands. Add .dockerignore files to exclude unnecessary files from the build context.",
            "status": "done",
            "testStrategy": "Build both Docker images to verify they compile without errors. Check that multi-stage builds are properly implemented. Verify non-root users are configured correctly. Confirm hot reload capability works in development mode."
          },
          {
            "id": 3,
            "title": "Configure Docker Compose for Development Environment",
            "description": "Create a docker-compose.dev.yml file that properly configures both services with appropriate networking, volumes for live reloading, and environment variables.",
            "dependencies": [],
            "details": "Create docker-compose.dev.yml file that defines both frontend and backend services. Configure volumes to mount source code for live reloading during development. Set up proper networking between services so frontend can communicate with backend. Define appropriate environment variables for development. Configure service dependencies to ensure proper startup order. Ensure the configuration works across Windows, macOS, and Linux platforms. Add comments explaining key configuration choices.",
            "status": "done",
            "testStrategy": "Start the services using docker-compose up and verify both containers start successfully. Test live reloading by making changes to source files. Verify frontend can communicate with backend through Docker networking."
          },
          {
            "id": 4,
            "title": "Implement Toolchain Version Pinning",
            "description": "Ensure consistent development environments by pinning toolchain versions in configuration files and documentation.",
            "dependencies": [],
            "details": "Create .nvmrc file in the frontend directory to pin Node.js to version 18.19.0. Add .python-version file in the backend directory to pin Python to version 3.12.0. Update package.json to specify exact versions of npm dependencies. Create requirements.txt with pinned Python package versions. Update versions.md with comprehensive version information for all tools and dependencies. Ensure Docker images use the same versions as specified in these files. Update README.md to reference these version requirements.",
            "status": "done",
            "testStrategy": "Verify that all version files exist and contain the correct version numbers. Confirm Docker builds use the specified versions. Check that package.json and requirements.txt align with the versions specified in versions.md."
          },
          {
            "id": 5,
            "title": "Enhance Repository Documentation and Hygiene",
            "description": "Improve repository documentation and setup additional development tools to ensure a smooth developer experience.",
            "dependencies": [],
            "details": "Update README.md with comprehensive setup instructions, including platform-specific commands for Windows (PowerShell), macOS, and Linux. Create a Makefile with common development tasks (build, test, lint, etc.). Add CONTRIBUTING.md with guidelines for contributors. Create root .gitignore file with comprehensive patterns. Add LICENSE file with appropriate license. Set up .editorconfig for consistent formatting across editors. Document environment variables in a .env.example file. Create a CHANGELOG.md file to track changes.",
            "status": "done",
            "testStrategy": "Review all documentation files for completeness and accuracy. Test Makefile targets to ensure they work as expected. Verify .gitignore patterns are effective by testing with common development artifacts."
          },
          {
            "id": 6,
            "title": "Perform Environment Verification and Smoke Testing",
            "description": "Validate the complete development environment setup with comprehensive testing across platforms and verify service connectivity.",
            "dependencies": [],
            "details": "Create a verification script that checks the repository structure against PRD requirements. Validate Docker configurations for best practices (multi-stage builds, non-root users, etc.). Test docker-compose.dev.yml on Windows, macOS, and Linux to ensure cross-platform compatibility. Verify frontend can reach backend API endpoints through Docker networking. Test hot-reloading functionality in both frontend and backend. Verify all environment variables are properly passed to containers. Document any platform-specific issues and workarounds.",
            "status": "done",
            "testStrategy": "Run the verification script to validate repository structure. Start the development environment on different platforms to verify cross-platform compatibility. Make test API calls from frontend to backend to verify connectivity. Make changes to source files to verify hot-reloading works correctly."
          }
        ]
      },
      {
        "id": 2,
        "title": "Configure CI/CD Pipeline",
        "description": "Set up GitHub Actions workflows for continuous integration and deployment",
        "details": "Create .github/workflows/ci.yml for running tests, linting, and building Docker images. Configure type checking for both TypeScript and Python. Set up linting with ESLint, Stylelint for frontend and Ruff, Black for backend. Configure test runners for Vitest (frontend) and pytest (backend) with coverage thresholds of 90%. Add Docker image building and vulnerability scanning with Trivy. For deployment, create deploy.yml to handle staging and production deployments using Helm charts.",
        "testStrategy": "Verify CI pipeline runs successfully on pull requests. Test that all quality gates (linting, type checking, tests) function correctly. Ensure Docker images are built and scanned properly. Validate that deployment workflow can be triggered manually.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CI Workflow Scaffolding",
            "description": "Set up the basic structure for GitHub Actions workflows with separate jobs for frontend and backend, including concurrency control and branch filters.",
            "dependencies": [],
            "details": "Create .github/workflows/ci.yml with workflow triggers for pull requests and pushes to main. Configure concurrency settings to prevent parallel runs on the same branch. Set up environment variables for Node 18.19.0 and Python 3.12.0. Define job matrix for frontend and backend. Add PR gating to prevent merging if CI fails. Include caching strategy for node_modules and pip dependencies keyed on lockfiles.",
            "status": "done",
            "testStrategy": "Verify workflow file passes GitHub Actions lint check. Test that workflow triggers correctly on PR and push events."
          },
          {
            "id": 2,
            "title": "Implement Frontend CI Jobs",
            "description": "Configure frontend CI jobs for type checking, linting, testing, and artifact generation.",
            "dependencies": [
              "2.1"
            ],
            "details": "In the ci.yml workflow, create a frontend job that runs on ubuntu-latest. Set up steps to checkout code, setup Node 18.19.0, install dependencies with npm ci, cache node_modules, run TypeScript type checking, execute ESLint and Stylelint with specific configurations, run Vitest tests with coverage threshold of 90%, and upload test reports and coverage as artifacts. Pin all GitHub Action versions for reproducibility.",
            "status": "done",
            "testStrategy": "Test the frontend CI job with a sample PR containing both passing and failing tests/lint to verify proper reporting."
          },
          {
            "id": 3,
            "title": "Implement Backend CI Jobs",
            "description": "Configure backend CI jobs for type checking, linting, testing, and artifact generation.",
            "dependencies": [
              "2.1"
            ],
            "details": "In the ci.yml workflow, create a backend job that runs on ubuntu-latest. Set up steps to checkout code, setup Python 3.12.0, install dependencies with pip and cache them, run Ruff for linting, Black for code formatting checks, Mypy for type checking, and pytest with coverage threshold of 90%. Upload test reports and coverage as artifacts. Ensure all tool versions are pinned.",
            "status": "done",
            "testStrategy": "Test the backend CI job with a sample PR containing both passing and failing tests/lint to verify proper reporting."
          },
          {
            "id": 4,
            "title": "Add Contract and Performance Testing",
            "description": "Implement API contract testing with Schemathesis and basic performance testing with k6.",
            "dependencies": [
              "2.3"
            ],
            "details": "Add a contract testing job that runs Schemathesis against the backend /openapi.json endpoint to validate API contracts. Include consumer verification steps. Create a performance testing job using k6 to run basic smoke tests for chat and slides endpoints with defined thresholds. Configure tests to be non-flaky with short durations suitable for CI. Upload test results as artifacts.",
            "status": "done",
            "testStrategy": "Verify contract tests correctly identify schema violations. Ensure performance tests have consistent results across multiple runs."
          },
          {
            "id": 5,
            "title": "Configure Docker Build and Security Scanning",
            "description": "Set up Docker image building with multi-stage builds and security scanning with Trivy.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "Create a Docker build job that builds frontend and backend images using multi-stage builds. Implement image size thresholds to prevent bloated images. Configure Trivy scanning for both images to detect vulnerabilities, failing the build on critical vulnerabilities. Generate and upload Software Bill of Materials (SBOM) for each image. Set up Docker layer caching to speed up builds.",
            "status": "done",
            "testStrategy": "Test Docker builds with intentionally vulnerable dependencies to verify Trivy correctly identifies and fails the build."
          },
          {
            "id": 6,
            "title": "Implement Security Checks",
            "description": "Add dedicated security scanning for both frontend and backend codebases.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "Create a security job that runs Bandit for Python backend code and npm audit for frontend dependencies. Configure the job to fail on high or critical vulnerabilities as specified in the PRD. Add CodeQL analysis for both JavaScript/TypeScript and Python code. Upload security scan results as artifacts and generate a security report summary.",
            "status": "done",
            "testStrategy": "Test security checks with known vulnerable dependencies to verify proper detection and reporting."
          },
          {
            "id": 7,
            "title": "Create Deployment Workflow",
            "description": "Set up GitHub Actions workflow for deploying to staging and production environments using Helm charts.",
            "dependencies": [
              "2.5"
            ],
            "details": "Create .github/workflows/deploy.yml that triggers on successful completion of the CI workflow for main branch (staging) and on release tags (production). Configure Kubernetes authentication using OIDC. Set up Helm chart deployment with environment-specific values. Implement pre-deployment validation and post-deployment health checks. Add manual approval step for production deployments. Configure rollback mechanism for failed deployments.",
            "status": "done",
            "testStrategy": "Test deployment to a test environment to verify Helm chart installation works correctly. Validate rollback functionality works when health checks fail."
          },
          {
            "id": 8,
            "title": "Implement Release Workflow and Status Reporting",
            "description": "Create a release workflow for building and publishing signed container images and implement CI status reporting.",
            "dependencies": [
              "2.5",
              "2.7"
            ],
            "details": "Create .github/workflows/release.yml triggered by release tags to build, sign with Cosign, and push container images to the registry. Add status badges to README.md showing CI status. Configure PR comments with test coverage summary and status reports. Implement release notes generation based on conventional commits. Set up notifications for failed workflows via Slack or email. Ensure the release workflow is disabled by default and requires manual triggering.",
            "status": "done",
            "testStrategy": "Test the release workflow with a sample tag to verify image building, signing, and pushing works correctly. Verify status badges update properly."
          }
        ]
      },
      {
        "id": 3,
        "title": "Define Backend Domain Models",
        "description": "Create Pydantic models for core data structures",
        "details": "Implement Pydantic v2 models in backend/app/models/ directory: ChatRequest (prompt, slide_count, model), ChatResponse, SlidePlan (title, bullets, notes), ImageMeta (url, alt_text), and PPTXJob (job_id, status, error_message, result_url). Configure models with strict validation, camelCase JSON serialization, and appropriate type hints. Add docstrings and examples for each model.",
        "testStrategy": "Write unit tests for model validation, serialization, and deserialization. Test edge cases like empty values, maximum lengths, and invalid inputs. Verify that models correctly convert between snake_case and camelCase for API responses.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Base Model Configuration",
            "description": "Set up a base Pydantic model with common configuration for all domain models",
            "dependencies": [],
            "details": "Create a BaseModel class in backend/app/models/base.py that extends Pydantic's BaseModel. Configure it with strict validation (model_config = {\"strict\": True}), camelCase JSON serialization using an alias_generator, and enable from_attributes. Add appropriate json_encoders for datetime and UUID types. Include docstrings explaining the base configuration and usage examples.",
            "status": "done",
            "testStrategy": "Test serialization/deserialization with camelCase conversion, verify strict validation is enforced, and ensure custom types like datetime and UUID are properly handled."
          },
          {
            "id": 2,
            "title": "Implement ChatRequest Model",
            "description": "Create the ChatRequest model for handling user prompt inputs",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement ChatRequest model in backend/app/models/chat.py that inherits from BaseModel. Include fields: prompt (str), slide_count (int), and model (str). Add validators to ensure prompt is not empty, slide_count is between 1-20, and model is one of the allowed values. Add appropriate type hints, docstrings, and JSON schema examples. Include field descriptions for OpenAPI documentation.",
            "status": "done",
            "testStrategy": "Test validation rules for each field with valid and invalid inputs. Verify error messages are clear and helpful. Test JSON serialization/deserialization with camelCase conversion."
          },
          {
            "id": 3,
            "title": "Implement ChatResponse Model",
            "description": "Create the ChatResponse model for AI-generated slide plan responses",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement ChatResponse model in backend/app/models/chat.py that inherits from BaseModel. Include fields for the response data structure containing the generated slide plan. Add appropriate type hints, docstrings, and JSON schema examples. Ensure the model properly references the SlidePlan model for structured slide content.",
            "status": "done",
            "testStrategy": "Test serialization/deserialization with nested models. Verify all fields are correctly represented in JSON output with camelCase conversion."
          },
          {
            "id": 4,
            "title": "Implement SlidePlan Model",
            "description": "Create the SlidePlan model for representing slide content structure",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement SlidePlan model in backend/app/models/slides.py that inherits from BaseModel. Include fields: title (str), bullets (List[str]), and notes (Optional[str]). Add validators to ensure title is not empty and has a reasonable maximum length (100 chars), bullets are not empty, and each bullet has a reasonable maximum length (200 chars). Add appropriate type hints, docstrings, and JSON schema examples.",
            "status": "done",
            "testStrategy": "Test validation rules for title and bullets with valid and invalid inputs. Test serialization/deserialization with camelCase conversion. Verify optional fields work correctly when omitted."
          },
          {
            "id": 5,
            "title": "Implement ImageMeta Model",
            "description": "Create the ImageMeta model for image metadata",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement ImageMeta model in backend/app/models/slides.py that inherits from BaseModel. Include fields: url (str) and alt_text (str). Add validators to ensure url is a valid URL format and alt_text is not empty. Add appropriate type hints, docstrings, and JSON schema examples. Include field descriptions for OpenAPI documentation.",
            "status": "done",
            "testStrategy": "Test URL validation with valid and invalid URLs. Test serialization/deserialization with camelCase conversion. Verify error messages for invalid URLs are clear and helpful."
          },
          {
            "id": 6,
            "title": "Implement PPTXJob Model",
            "description": "Create the PPTXJob model for tracking slide generation jobs",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement PPTXJob model in backend/app/models/jobs.py that inherits from BaseModel. Include fields: job_id (UUID), status (str, with allowed values like 'pending', 'processing', 'completed', 'failed'), error_message (Optional[str]), and result_url (Optional[str]). Add validators to ensure status is one of the allowed values. Add appropriate type hints, docstrings, and JSON schema examples.",
            "status": "done",
            "testStrategy": "Test validation rules for status field with valid and invalid values. Test UUID handling and serialization. Verify optional fields work correctly when omitted."
          },
          {
            "id": 7,
            "title": "Implement Error Response Models",
            "description": "Create standardized error response models",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement ErrorResponse model in backend/app/models/errors.py that inherits from BaseModel. Include fields: error_code (str), message (str), and details (Optional[Dict]). Create specific error subclasses for common error scenarios (ValidationError, NotFoundError, etc.). Add appropriate type hints, docstrings, and JSON schema examples. Include field descriptions for OpenAPI documentation.",
            "status": "done",
            "testStrategy": "Test serialization of different error types. Verify error details are properly included in the response. Test with various error scenarios to ensure consistent error format."
          },
          {
            "id": 8,
            "title": "Create Model Unit Tests",
            "description": "Implement comprehensive unit tests for all domain models",
            "dependencies": [
              "3.2",
              "3.3",
              "3.4",
              "3.5",
              "3.6",
              "3.7"
            ],
            "details": "Create test files in tests/models/ directory for each model. Implement parametrized pytest tests covering valid/invalid payloads, field validation, aliasing (snake_case to camelCase conversion), and error messages. Test serialization/deserialization roundtrips for all models. Verify models appear correctly in the OpenAPI schema with proper descriptions and examples.",
            "status": "done",
            "testStrategy": "Run tests with pytest. Verify all validation rules are properly tested with both valid and invalid inputs. Ensure test coverage for all models and their fields. Test integration with FastAPI's OpenAPI schema generation."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement LLM Service Integration",
        "description": "Create service to interact with OpenRouter API for slide outline generation",
        "details": "Implement LLM service in backend/app/services/llm.py that connects to OpenRouter API. Create async functions to send prompts and receive responses. Implement proper error handling with retries (up to 3 attempts with exponential backoff). Parse LLM responses into structured SlidePlan objects. Add configuration for API keys via environment variables. Implement prompt engineering to ensure consistent slide outline format.",
        "testStrategy": "Write unit tests with mocked API responses. Test error handling and retry logic. Create integration tests that use a test API key with rate limits. Verify that different prompt types produce valid SlidePlan structures.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LLM Service Configuration Module",
            "description": "Implement configuration module for LLM service that loads API keys and settings from environment variables",
            "dependencies": [],
            "details": "Create a configuration module in backend/app/core/config.py that loads OpenRouter API key, base URL, timeout settings, and default model from environment variables. Implement validation to ensure required variables are present. Define environment variable names following project conventions (e.g., OPENROUTER_API_KEY, OPENROUTER_BASE_URL). Add configuration for logging settings including whether to log prompts. Include model allowlist configuration.",
            "status": "done",
            "testStrategy": "Write unit tests to verify configuration loading from environment variables. Test validation logic for missing required variables. Mock environment variables for testing."
          },
          {
            "id": 2,
            "title": "Implement AsyncClient Factory",
            "description": "Create a factory function for httpx.AsyncClient with proper configuration",
            "dependencies": [
              "4.1"
            ],
            "details": "Implement a factory function in backend/app/services/llm.py that creates and configures an httpx.AsyncClient with appropriate timeouts, headers (including API key from config), and base URL. Ensure the client is properly configured for async operation. Implement proper client lifecycle management including close behavior. Make the factory function dependency-injection friendly.",
            "status": "done",
            "testStrategy": "Test that the client is created with correct configuration. Verify headers include API key. Test client close behavior."
          },
          {
            "id": 3,
            "title": "Define Request and Response Models",
            "description": "Create Pydantic models for LLM service requests and responses",
            "dependencies": [
              "4.1"
            ],
            "details": "Define Pydantic models in backend/app/models/llm.py for ChatRequest (containing prompt, slideCount, model, language, context fields) and ChatResponse/SlidePlan (containing structured slide outline). Include validation for all fields. Add trace/job ID fields for tracking requests. Implement model for upstream API request payload and response parsing.",
            "status": "done",
            "testStrategy": "Test model validation with valid and invalid inputs. Verify required fields are enforced. Test conversion between internal and upstream models."
          },
          {
            "id": 4,
            "title": "Implement Request Construction and Submission",
            "description": "Create function to construct and submit requests to OpenRouter API",
            "dependencies": [
              "4.2",
              "4.3"
            ],
            "details": "Implement async function send_chat_request that takes a ChatRequest, constructs the appropriate payload for OpenRouter API, and submits it using the AsyncClient. Include trace/job IDs in the request for tracking. Handle model selection logic, using the provided model or falling back to the default from configuration. Validate the model against the allowlist.",
            "status": "done",
            "testStrategy": "Use respx to mock API responses. Test successful request submission. Verify payload construction is correct. Test model selection and validation logic."
          },
          {
            "id": 5,
            "title": "Implement Response Parsing",
            "description": "Create function to parse API responses into structured SlidePlan objects",
            "dependencies": [
              "4.3",
              "4.4"
            ],
            "details": "Implement function to parse JSON responses from OpenRouter API into ChatResponse/SlidePlan objects. Add strict validation to ensure the response matches expected format. Implement helpful error messages for malformed responses. Handle different response structures that might come from different models.",
            "status": "done",
            "testStrategy": "Test parsing with various response formats. Test handling of malformed responses. Verify validation logic works correctly."
          },
          {
            "id": 6,
            "title": "Implement Error Handling and Retries",
            "description": "Add robust error handling with retry logic for API requests",
            "dependencies": [
              "4.4"
            ],
            "details": "Implement error handling for API requests using tenacity for retries. Configure exponential backoff with jitter. Set maximum of 3 retry attempts. Create custom LLMError class to represent different failure modes. Map upstream failures and timeouts to appropriate error types. Ensure API keys and sensitive information are masked in logs and error messages.",
            "status": "done",
            "testStrategy": "Test retry behavior with mocked timeouts and errors. Verify exponential backoff works correctly. Test that sensitive information is properly masked in logs and errors."
          },
          {
            "id": 7,
            "title": "Add Metrics and Logging",
            "description": "Implement metrics collection and structured logging for LLM service",
            "dependencies": [
              "4.4",
              "4.6"
            ],
            "details": "Add Prometheus metrics for request counts, latencies, retries, and errors. Implement structured logging with correlation IDs. Ensure logs include relevant information for debugging while respecting privacy settings. Add log redaction for sensitive information. Configure log levels appropriately.",
            "status": "done",
            "testStrategy": "Test that metrics are incremented correctly for different scenarios. Verify logs contain expected information. Test redaction of sensitive information in logs."
          },
          {
            "id": 8,
            "title": "Implement Rate Limiting and Backoff Handling",
            "description": "Add support for handling rate limits and backoff hints from the API",
            "dependencies": [
              "4.6"
            ],
            "details": "Implement handling for 429 status codes and Retry-After headers. Respect rate limiting signals from the API. Propagate appropriate error messages via ErrorResponse when rate limited. Implement backoff strategy based on API hints.",
            "status": "done",
            "testStrategy": "Test handling of 429 responses with various Retry-After values. Verify backoff behavior matches API hints. Test error message propagation."
          },
          {
            "id": 9,
            "title": "Create Unit Tests for LLM Service",
            "description": "Implement comprehensive unit tests for all LLM service components",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4",
              "4.5",
              "4.6",
              "4.7",
              "4.8"
            ],
            "details": "Create unit tests using respx to mock API responses. Test success scenarios, timeouts, 5xx errors, 4xx errors, and malformed payloads. Verify metrics are incremented correctly. Test retry logic works as expected. Ensure all error paths are covered. Test configuration loading and validation.",
            "status": "done",
            "testStrategy": "Run tests with pytest. Use coverage tools to ensure high test coverage. Mock external dependencies appropriately."
          },
          {
            "id": 10,
            "title": "Implement Integration Test for Chat Generation Endpoint",
            "description": "Create integration test for the complete LLM service flow",
            "dependencies": [
              "4.9"
            ],
            "details": "Implement route-level test for POST /chat/generate that exercises the full flow with mocked upstream API. Verify request/response contract alignment. Test different input scenarios including various prompt types. Ensure the endpoint correctly uses the LLM service and returns appropriate responses.",
            "status": "done",
            "testStrategy": "Use TestClient from FastAPI for testing the endpoint. Mock the upstream API responses. Test various input scenarios including edge cases. Verify response structure matches expected format."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Image Generation Service",
        "description": "Create service to generate images for slides using Stability AI API",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "Implement image service in `backend/app/services/images.py` using Stability AI (Stable Image Generation) endpoints. Create async functions to generate images from slide content (title and bullets), support batching via `asyncio.gather`, robust retries with exponential backoff + jitter, rate-limit handling (429/Retry-After), and fallback to placeholder images on failures. Read API key/base URL/timeouts from config/env. Add basic caching (in-memory) keyed by normalized prompts to avoid regenerating identical images. Validate and return `ImageMeta` with `url` or persisted path. Ensure logs redact secrets and prompts when disabled.",
        "testStrategy": "Write unit tests with respx-mocked tests for success, 4xx/5xx, timeouts, rate limits, batching behavior, caching reuse, and fallback image path. Verify `ImageMeta` validation and that service returns a list aligned to input slides. Ensure no provider-specific assumptions leak into `SlidePlan`/`ImageMeta` models.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Configuration and Environment Variables",
            "description": "Implement configuration loading for Stability AI service including API key, base URL, and timeout settings from environment variables",
            "dependencies": [],
            "details": "Create a StabilityAIConfig class in `backend/app/config.py` that loads and validates STABILITY_API_KEY, STABILITY_BASE_URL, and STABILITY_TIMEOUT_SECONDS from environment variables. Include default values for base URL and timeout. Add validation to ensure API key is present. Document required .env keys and implement logging redaction for sensitive values.",
            "status": "done",
            "testStrategy": "Test config loading with various environment setups, verify validation logic, and ensure secrets are properly redacted in logs."
          },
          {
            "id": 2,
            "title": "Create Async HTTP Client Factory",
            "description": "Implement a factory function to create and configure an httpx.AsyncClient for Stability AI API requests",
            "dependencies": [
              "5.1"
            ],
            "details": "Create an async function `create_stability_client` in `backend/app/services/images.py` that returns a configured httpx.AsyncClient with base URL, timeouts, and authorization header using the API key from config. Implement proper lifecycle management with async context manager support and close method. Make it dependency-injection friendly.",
            "status": "done",
            "testStrategy": "Test client creation with various config values, verify headers are set correctly, and ensure client is properly closed when context exits."
          },
          {
            "id": 3,
            "title": "Implement Prompt Builder",
            "description": "Create utility to generate image prompts from slide content",
            "dependencies": [],
            "details": "Implement a `build_prompt` function that derives an image generation prompt from a SlidePlan object using title and bullet points. Include normalization logic for creating consistent cache keys. Support pluggable style presets through an optional style parameter. Ensure prompts are properly formatted for Stability AI API.",
            "status": "done",
            "testStrategy": "Test prompt generation with various slide contents, verify normalization logic, and test different style presets."
          },
          {
            "id": 4,
            "title": "Define Request and Response Schemas",
            "description": "Create Pydantic models for Stability AI API requests and responses",
            "dependencies": [
              "5.2"
            ],
            "details": "Define Pydantic models in `backend/app/models/stability.py` for Stability AI API payloads and responses. Include models for generation parameters, request body, and response structure. Ensure models are decoupled from provider specifics to allow for future provider changes. Include URL response handling for image results.",
            "status": "done",
            "testStrategy": "Test model validation with sample payloads, verify serialization/deserialization works correctly."
          },
          {
            "id": 5,
            "title": "Implement Single Image Generation",
            "description": "Create core function to generate a single image from a slide plan",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Implement `generate_image_for_slide(slide_plan: SlidePlan) -> ImageMeta` function that uses the HTTP client to call Stability AI API. Include retry logic with exponential backoff and jitter. Handle 429 rate limit responses by respecting Retry-After headers. Return properly structured ImageMeta with URL and metadata. Include helpful error messages for failures.",
            "status": "done",
            "testStrategy": "Test successful generation, various error scenarios (4xx/5xx), timeout handling, and rate limit handling with mocked responses using respx."
          },
          {
            "id": 6,
            "title": "Implement Batch Image Generation",
            "description": "Create function to generate multiple images concurrently",
            "dependencies": [
              "5.5"
            ],
            "details": "Implement `generate_images(slides: List[SlidePlan]) -> List[ImageMeta]` function using asyncio.gather to process multiple slides concurrently. Include bounded concurrency to prevent overwhelming the API. Ensure ordering guarantees so returned images match input slide order. Handle partial failures gracefully.",
            "status": "done",
            "testStrategy": "Test batch processing with various input sizes, verify concurrency limits, test ordering guarantees, and validate error handling during partial failures."
          },
          {
            "id": 7,
            "title": "Implement Caching Layer",
            "description": "Add in-memory caching to avoid regenerating identical images",
            "dependencies": [
              "5.3",
              "5.5"
            ],
            "details": "Implement an in-memory cache for generated images keyed by normalized prompt and style. Include TTL (time-to-live) and size cap for cache entries. Add cache hit metrics for monitoring. Modify the generate_image_for_slide function to check cache before making API calls.",
            "status": "done",
            "testStrategy": "Test cache hits and misses, verify TTL functionality, test size cap enforcement, and validate metrics recording."
          },
          {
            "id": 8,
            "title": "Implement Fallback Strategy",
            "description": "Create fallback mechanism to handle image generation failures",
            "dependencies": [
              "5.5"
            ],
            "details": "Implement fallback logic to return placeholder images when generation fails. Configure a default placeholder URL in the config. Set provider=\"placeholder\" in the ImageMeta for fallback images to distinguish them. Make fallback behavior configurable.",
            "status": "done",
            "testStrategy": "Test fallback under various failure conditions, verify placeholder images are returned correctly, and validate provider field is set appropriately."
          },
          {
            "id": 9,
            "title": "Add Metrics and Logging",
            "description": "Implement comprehensive metrics and logging for the image service",
            "dependencies": [
              "5.5",
              "5.6",
              "5.7"
            ],
            "details": "Add counters and histograms for requests, latency, retries, rate limits, and cache hits. Implement structured logging throughout the service. Ensure prompts are redacted in logs unless explicitly enabled. Create helper functions for consistent metric recording.",
            "status": "done",
            "testStrategy": "Test metric recording for various scenarios, verify log redaction works correctly, and validate all key events are properly logged."
          },
          {
            "id": 10,
            "title": "Write Comprehensive Tests",
            "description": "Create test suite for the image generation service",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4",
              "5.5",
              "5.6",
              "5.7",
              "5.8",
              "5.9"
            ],
            "details": "Implement respx-mocked tests for all service functions covering success cases, 4xx/5xx errors, timeouts, rate limits, batching behavior, cache reuse, and fallback paths. Verify ImageMeta validation works correctly. Test that batch results maintain correct ordering. Create test fixtures for common test scenarios.",
            "status": "done",
            "testStrategy": "Run tests with various mocked API responses, verify all edge cases are covered, and ensure tests are isolated and repeatable."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement PPTX Builder Service",
        "description": "Create service to generate PowerPoint files from slide plans and images",
        "details": "Implement PPTX builder in backend/app/services/pptx.py using python-pptx library. Create functions to generate slides with titles, bullet points, and images. Implement proper layout and formatting for consistent slide appearance. Add support for speaker notes if provided. Create a basic slide template with placeholders for content. Implement file saving to temporary location with unique identifiers.",
        "testStrategy": "Write unit tests to verify PPTX generation with various inputs. Test with missing images to ensure fallback works. Validate generated PPTX files can be opened in PowerPoint. Check that slide content matches input data.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PPTX Template and Layout Manager",
            "description": "Implement a template manager that loads or creates a base PowerPoint template with consistent layouts for title and content slides.",
            "dependencies": [],
            "details": "Create a `PPTXTemplateManager` class in `backend/app/services/pptx.py` that handles template loading from a .potx file if available or creates a default template with consistent layouts. Define standard slide layouts (title slide, content with image, bullet points only). Implement methods to access these layouts and apply them to new slides. Configure font families, sizes, and colors for consistency.",
            "status": "done",
            "testStrategy": "Test template loading with both valid and missing template files. Verify the default template creation works correctly. Check that all required layouts are available."
          },
          {
            "id": 2,
            "title": "Implement Text Rendering for Slides",
            "description": "Create functionality to add formatted titles and bullet points to slides with proper text formatting and handling of long text.",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement a `TextRenderer` class that handles adding text elements to slides. Create methods for adding slide titles with consistent formatting. Implement bullet point rendering with support for multiple levels. Add text wrapping and truncation logic for long text. Document the rules for text handling (character limits, wrapping behavior). Handle font, size, and formatting consistently.",
            "status": "done",
            "testStrategy": "Test with various text lengths including very long titles and bullet points. Verify proper wrapping and formatting. Test with special characters and Unicode text."
          },
          {
            "id": 3,
            "title": "Implement Image Processing and Placement",
            "description": "Create functionality to download, process, and place images on slides with proper sizing and positioning.",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement an `ImageProcessor` class that handles image fetching from URLs in `ImageMeta`. Add methods to download images with proper timeout handling. Implement image placement on slides with consistent positioning. Maintain aspect ratios and implement fit/contain strategy. Add center alignment for images. Implement fallback to placeholder image if fetch fails or on error.",
            "status": "done",
            "testStrategy": "Test image downloading with valid and invalid URLs. Verify image placement and sizing. Test timeout handling and fallback to placeholder."
          },
          {
            "id": 4,
            "title": "Add Speaker Notes Support",
            "description": "Implement functionality to add speaker notes to slides when provided.",
            "dependencies": [
              "6.1"
            ],
            "details": "Add methods to the slide generation process to attach speaker notes when provided in the slide plan. Ensure notes are properly formatted and visible in the notes pane when viewing the presentation. Handle long notes with proper formatting.",
            "status": "done",
            "testStrategy": "Test adding notes of various lengths. Verify notes appear correctly when opening the generated PPTX file."
          },
          {
            "id": 5,
            "title": "Implement Accessibility Features",
            "description": "Ensure generated presentations include accessibility features like alt text for images.",
            "dependencies": [
              "6.3"
            ],
            "details": "Extend the `ImageProcessor` to add alt text to images using the `altText` field from `ImageMeta`. Document any limitations of python-pptx for accessibility features. Implement best practices for accessible PowerPoint generation. Add methods to verify and report on accessibility compliance of generated slides.",
            "status": "done",
            "testStrategy": "Test that alt text is correctly added to images. Verify accessibility features work when opening the file in PowerPoint."
          },
          {
            "id": 6,
            "title": "Create File Output and Management System",
            "description": "Implement functionality to save generated PPTX files to a temporary location with unique identifiers.",
            "dependencies": [],
            "details": "Create a `FileManager` class that handles saving PPTX files to a configurable temporary directory. Generate UUID-based filenames for uniqueness. Implement methods to return file paths or optionally file bytes. Document cleanup strategy for temporary files. Add configuration options for temp directory location.",
            "status": "done",
            "testStrategy": "Test file saving with various output options. Verify unique filenames are generated. Test cleanup functionality."
          },
          {
            "id": 7,
            "title": "Implement Progress Tracking and Callbacks",
            "description": "Add support for progress tracking during PPTX generation to enable frontend progress updates.",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Implement a progress tracking system that can report on the status of PPTX generation. Add support for optional callback functions that can be called at various stages (per slide, on completion, etc.). Design the callback system to work with WebSockets without creating a hard dependency. Track percentage complete and current operation.",
            "status": "done",
            "testStrategy": "Test progress reporting with and without callbacks. Verify accurate progress percentage calculation."
          },
          {
            "id": 8,
            "title": "Implement Robust Error Handling",
            "description": "Create comprehensive error handling for the PPTX generation process with detailed error reporting.",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4",
              "6.6"
            ],
            "details": "Implement exception handling throughout the PPTX generation process. Create custom exception classes for different error types (TemplateError, ImageError, etc.). Implement continue-on-error functionality for individual slides. Add detailed error logging. Create a results summary object that includes successes and failures. Implement graceful degradation for non-critical errors.",
            "status": "done",
            "testStrategy": "Test error handling with various failure scenarios (missing template, bad image URLs, invalid content). Verify the service continues processing when appropriate and returns useful error information."
          },
          {
            "id": 9,
            "title": "Create Main PPTX Builder Service",
            "description": "Implement the main service class that orchestrates the entire PPTX generation process.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4",
              "6.5",
              "6.6",
              "6.7",
              "6.8"
            ],
            "details": "Create the main `PPTXBuilder` class that integrates all components. Implement the primary `generate_presentation` method that takes a list of `SlidePlan` objects and generates a complete PPTX file. Add configuration options for HTTP timeouts, temp directory, max image size, and font defaults. Implement proper initialization and cleanup. Create a simple API for the service that can be called from other parts of the application.",
            "status": "done",
            "testStrategy": "Test end-to-end PPTX generation with various inputs. Verify all components work together correctly. Test with edge cases like empty slide plans or missing data."
          },
          {
            "id": 10,
            "title": "Write Comprehensive Unit Tests",
            "description": "Create a suite of unit tests for the PPTX Builder service and its components.",
            "dependencies": [
              "6.9"
            ],
            "details": "Implement unit tests for all PPTX Builder components. Create test fixtures with sample slide plans and image metadata. Implement mocks for external dependencies like HTTP requests for images. Write tests that verify slide count, content presence, and file integrity. Create tests for error conditions and edge cases. Implement integration tests that verify the generated files can be opened in PowerPoint.",
            "status": "done",
            "testStrategy": "Run tests with pytest. Use mocks for external dependencies. Verify test coverage meets project standards. Include both unit tests for individual components and integration tests for the complete service."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Backend API Routes",
        "description": "Create FastAPI endpoints for chat generation and slide building",
        "details": "Implement API routes in backend/app/api/ directory. Create chat.py with POST /chat/generate endpoint that accepts ChatRequest and returns ChatResponse. Implement slides.py with POST /slides/build endpoint to initiate slide generation. Add GET /slides/download endpoint for file retrieval. Implement proper error handling and status codes. Add request validation using Pydantic models. Generate OpenAPI schema for frontend consumption.",
        "testStrategy": "Write API tests using TestClient. Test successful and error scenarios for each endpoint. Verify request validation works correctly. Test with various input combinations. Validate OpenAPI schema generation is correct.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement WebSocket Server for Real-time Updates",
        "description": "Create Socket.IO server for sending progress updates during slide generation",
        "details": "Implement Socket.IO server in backend/app/socketio_app.py using python-socketio. Create event handlers for client connections. Implement authentication for WebSocket connections using session IDs. Create functions to emit 'slide:progress' events during generation. Add 'slide:completed' event emission when PPTX is ready. Integrate WebSocket server with FastAPI application.",
        "testStrategy": "Write tests for WebSocket server using Socket.IO client. Test connection, authentication, and event emission. Verify clients receive progress updates correctly. Test reconnection handling and missed events.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Backend Observability and Error Handling",
        "description": "Add logging, metrics, and comprehensive error handling to backend",
        "details": "Implement structured logging using structlog with JSON output. Add request ID tracking across services. Create custom exceptions for different error scenarios. Implement global exception handlers in FastAPI. Add Prometheus metrics endpoint with custom metrics for API latency, slide generation counts, and error rates. Implement health check endpoint. Add detailed error responses with appropriate HTTP status codes.",
        "testStrategy": "Test logging output format and content. Verify metrics endpoint returns correct data. Test exception handling for various error scenarios. Verify health check endpoint works correctly.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Authentication System",
        "description": "Create passwordless authentication system using magic links and JWT",
        "details": "Implement auth module in backend/app/core/auth.py. Create JWT generation and validation functions. Implement magic link email generation (logging to console in development). Create /auth/login endpoint to request magic links. Add /auth/refresh endpoint for token renewal. Implement FastAPI dependencies for protected routes. Add JWT middleware for authentication. Configure JWT secret via environment variables.",
        "testStrategy": "Test JWT generation and validation. Verify magic link flow works correctly. Test token refresh functionality. Verify protected routes reject unauthorized requests. Test token expiration and renewal.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Setup Frontend Project with Vite and React",
        "description": "Initialize frontend React application with TypeScript and Vite",
        "details": "Create frontend project using Vite with React and TypeScript. Configure Tailwind CSS for styling. Set up ESLint and Prettier for code quality. Add shadcn/UI components library. Configure Vitest for unit testing. Set up environment variables for development and production. Create directory structure following feature-based organization. Configure absolute imports for cleaner imports.",
        "testStrategy": "Verify application builds and runs correctly. Test hot module reloading functionality. Ensure ESLint and Prettier configurations work. Validate test setup with sample component tests.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Generate TypeScript API Client from OpenAPI",
        "description": "Create type-safe API client from backend OpenAPI schema",
        "details": "Set up openapi-typescript-codegen to generate API client. Create script to fetch OpenAPI schema from backend and generate TypeScript client. Implement custom templates for React Query integration. Generate hooks for API endpoints (useGenerateChatMutation, useBuildSlidesMutation). Add types for all request and response models. Configure error handling and response parsing.",
        "testStrategy": "Verify generated client matches backend API contract. Test generated hooks with mock data. Ensure type safety between frontend and backend. Validate error handling works correctly.",
        "priority": "high",
        "dependencies": [
          7,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Frontend Routing with TanStack Router",
        "description": "Set up application routing for chat and slides pages",
        "details": "Install and configure TanStack Router v1. Create route definitions for main application pages. Implement lazy loading for route components. Create root route that redirects to chat. Add chat route with session ID parameter. Implement not found page for invalid routes. Add route guards for authentication if needed.",
        "testStrategy": "Test route navigation and parameters. Verify lazy loading works correctly. Test redirect functionality. Ensure route guards prevent unauthorized access if implemented.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Frontend State Management with Zustand",
        "description": "Create state stores for chat and slides data",
        "details": "Set up Zustand v4.5 for state management. Create ChatStore for managing chat messages and session data. Implement SlideStore for slide generation state and progress. Add immer middleware for immutable updates. Implement persistence for session data if needed. Create selectors for efficient component rendering. Add TypeScript types for all store states and actions.",
        "testStrategy": "Write unit tests for store actions and selectors. Test state updates and immutability. Verify persistence works if implemented. Test store interactions with components.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement WebSocket Hook for Real-time Updates",
        "description": "Create custom hook for WebSocket communication with backend",
        "details": "Implement useWebSocket custom hook using Socket.IO client. Add connection management with automatic reconnection. Create event listeners for 'slide:progress' and 'slide:completed' events. Implement authentication for WebSocket connection. Add connection status tracking. Create typed event handlers for different message types.",
        "testStrategy": "Test WebSocket connection and event handling. Verify reconnection logic works. Test event listeners with mock server. Ensure authentication works correctly. Validate typed event handlers process data correctly.",
        "priority": "medium",
        "dependencies": [
          8,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Core Layout Components",
        "description": "Create layout components for application structure",
        "details": "Implement Header component with application branding. Create Sidebar component for navigation. Implement MainLayout component as container for pages. Add responsive design using Tailwind CSS. Create loading and error states for layout. Implement theme support if needed. Add accessibility attributes for screen readers.",
        "testStrategy": "Test layout components rendering. Verify responsive behavior on different screen sizes. Test accessibility with axe-core. Ensure layout components work with different content.",
        "priority": "high",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Chat UI Components",
        "description": "Create components for chat-based interaction",
        "details": "Implement ChatContainer component to manage chat flow. Create ChatInput component for user prompts. Implement ChatMessage component for displaying messages. Create ModelSelector component for AI model selection. Implement SlidePlanPreview component to display generated outlines. Add animations for message appearance using Framer Motion. Implement auto-scrolling for new messages.",
        "testStrategy": "Test chat components rendering and interaction. Verify input validation works. Test with different message types and content. Ensure animations work correctly. Validate accessibility for all components.",
        "priority": "high",
        "dependencies": [
          14,
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Slide Generation UI Components",
        "description": "Create components for slide generation and progress display",
        "details": "Implement SlideGenerator component to initiate slide generation. Create ProgressIndicator component for generation progress. Implement DownloadButton component for PPTX download. Add error handling and retry functionality. Create loading states and animations. Implement notifications for completion and errors.",
        "testStrategy": "Test slide generation components with mock data. Verify progress updates display correctly. Test download functionality. Ensure error states and retries work. Validate accessibility for all components.",
        "priority": "high",
        "dependencies": [
          15,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Download Manager",
        "description": "Create utility for handling PPTX file downloads",
        "details": "Implement DownloadManager utility for file downloads. Add support for resumable downloads using range requests. Implement download progress tracking. Add error handling and retry functionality. Create download status notifications. Implement file saving with proper filename.",
        "testStrategy": "Test download functionality with various file sizes. Verify resume capability works. Test error handling and retries. Ensure progress tracking is accurate. Validate file saving works correctly.",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Chat Page Integration",
        "description": "Integrate chat components with API and state management",
        "details": "Create ChatPage component integrating all chat UI components. Connect to ChatStore for state management. Implement API calls using generated hooks. Add optimistic UI updates for better user experience. Implement error handling and loading states. Add session management if needed. Create smooth transitions between states.",
        "testStrategy": "Test end-to-end chat flow with mock API. Verify state updates correctly. Test error handling and recovery. Ensure loading states display properly. Validate optimistic updates work correctly.",
        "priority": "high",
        "dependencies": [
          12,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Slide Generation Integration",
        "description": "Integrate slide generation with API, WebSockets, and download",
        "details": "Connect SlideGenerator to API for initiating generation. Implement WebSocket connection for progress updates. Connect DownloadManager for file retrieval. Add error handling and retry functionality. Implement state management for generation process. Create smooth transitions between states.",
        "testStrategy": "Test end-to-end slide generation flow. Verify WebSocket updates display correctly. Test download functionality with real files. Ensure error handling and retries work. Validate state transitions are smooth.",
        "priority": "high",
        "dependencies": [
          15,
          18,
          19,
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Authentication UI",
        "description": "Create components for user authentication",
        "details": "Implement LoginPage component for email input. Create MagicLinkPage for handling link clicks. Implement authentication state management. Add protected route handling. Create loading and error states for authentication. Implement token refresh logic. Add persistence for authentication state.",
        "testStrategy": "Test authentication flow end-to-end. Verify protected routes work correctly. Test token refresh functionality. Ensure error states display properly. Validate persistence works across page reloads.",
        "priority": "medium",
        "dependencies": [
          10,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement End-to-End Testing",
        "description": "Create Cypress tests for critical user flows",
        "details": "Set up Cypress for end-to-end testing. Create tests for main user flow: entering prompt, receiving outline, generating slides, downloading PPTX. Implement tests for authentication if implemented. Add accessibility testing with cypress-axe. Create test fixtures and mocks for external services. Implement visual regression testing if needed.",
        "testStrategy": "Run tests in CI pipeline. Verify tests pass consistently. Test on multiple browsers (Chrome, Firefox). Ensure tests cover critical user paths. Validate accessibility compliance.",
        "priority": "medium",
        "dependencies": [
          21,
          22
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement Performance Optimization",
        "description": "Optimize frontend and backend performance",
        "details": "Implement code splitting for frontend routes. Add lazy loading for components. Optimize image loading and processing. Implement caching strategies for API responses. Add memoization for expensive computations. Optimize WebSocket message frequency. Implement backend response compression. Add database indexes if database is added later.",
        "testStrategy": "Run Lighthouse performance audits. Measure and compare load times before and after optimization. Test with slow network conditions. Verify bundle sizes are within budget. Validate that optimizations don't break functionality.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Create Kubernetes Deployment Configuration",
        "description": "Prepare Helm charts for Kubernetes deployment",
        "details": "Create Helm charts for application deployment. Configure Deployments for frontend and backend. Set up Services and Ingress resources. Add ConfigMaps and Secrets for configuration. Configure horizontal pod autoscaling. Implement health checks and readiness probes. Add resource limits and requests. Configure persistent volumes if needed. Implement blue/green deployment strategy.",
        "testStrategy": "Deploy to test Kubernetes cluster. Verify all components start correctly. Test scaling under load. Ensure configuration is properly applied. Validate blue/green deployment works. Test health checks and recovery.",
        "priority": "medium",
        "dependencies": [
          2,
          9,
          24
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-09T09:35:23.960Z",
      "updated": "2025-08-09T11:39:40.057Z",
      "description": "Tasks for master context"
    }
  }
}